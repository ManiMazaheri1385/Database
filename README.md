# پروژه عید 😭😭🪻🍎🪞🥚🪙🎆🧄🌱🐍
## یا به عبارتی ساختن To-Do List 📃📝✍🏻
### Bonjour!
توی این پروژه (آخه واسه عید هم پروژه ولمان کنید لطفاً 😭😭) قراره با هم از اون لیست‌ها بسازیم که وقتی کارهامون رو توش می‌نویسیم هیچ وقت انجامشون نمی‌دیم! 🥰🤓
## db package
## &nbsp; exception package
- توی این پکیج عزیز قراره که دوتا exception تعریف بشن:
- `EntityNotFoundException`: ایشون یه checked exception هستن (چون داره مستقیماً از کلاس Exception ارث‌بری می‌کنه) پس حتما باید هندل بشن.
- `InvalidEntityException`: و ایشون یه un-checked exception هستن (این داره از کلاس RuntimeException ارث‌بری می‌کنه) نیازی به هندل کردن‌اش نیست ولی بهتره که هندل بشه.
---
## &nbsp; **classes:**
### &nbsp; &nbsp; Database
#### کلاس Database محل مدیریت کل dataهامون هست و خیلی مهمه. 😱😱
#### ابتدا فیلدها:
- فیلد‌های این کلاس همه private هستن تا کسی نتونه بهشون دستبرد بزنه (🥷🏻🏴‍☠️) <br />
فیلد `identifier` برای تخصیص ID به entityها و ArrayListعه `entities` برای ذخیره entityها هنگام اجرای برنامه و دوتا HashMapعه `validators` و `serializers` که از اسمشون پیداست برای مدیریت همون‌هایی هستن که تو اسمشون هستن.
#### نوبت متد‌ها رسیده:
- متد `add` برای اضافه کردن entityها به ArrayListمون یعنی `entities` هست اول توش با validatorها چک می‌کنه چیزی که قراره بیاد تو Database پرت و پلا نباشه بعد اگه از این مرحله گذر کرد بهش زمان ساخت و ID می‌ده و به Databae اضافه‌اش می‌کنه.
- متد `get` یه ID می‌گیره بعد entity مربوطه رو return می‌کنه، اگه نبود هم یه exception تقدیم حضور متعالی‌تون می‌کنه.
- متد `delete` یه ID می‌گیره و سپس entity مربوطه رو از `entities` پاک می‌کنه اگه Task باشه هم کل Stepهاش رو پاک می‌کنه؛ اگه همچین entityای نبود چی؟ به نام خدا exception. 😁😁
- متد `update` ایشون entity می‌گیره و اول با validator نگاه می‌کنه ببینه اصلا این entity با آرمان‌ها همخونی داره یا نه که اگه نداشت exception و اگه داشت هم زمان تغییرات جدید بهش می‌ده و بعد entity جدید رو با قبلی جایگزین می‌کنه.
- متد `save` وقتی برنامه رو می‌بندیم ایشون می‌آد dataها رو توی فایل data.json ذخیره‌سازی می‌کنه که از دست نرن!
- متد `load` وقتی هم برنامه رو باز می‌کنین این یکی‌شون می‌آد dataها رو پردازش می‌کنه تا بشه مجدداً ازشون استفاده نمایید!
- متد `getAll` اول کد entityهای مورد نظر رو می‌دریافته و سپس کل اون‎‌ها رو در قالب یک عدد صابون 🧼🫧 (هاهاها 🥰🥰🤣🤣) ArrayList به ما می‌ده.
- متد `registerValidator` برای اضافه کردن Validatorها به HashMap مربوطه هست.
- متد `registerSerializer` نیز برای افزودن Serializerها به HashMap مربوطه است.
- چقدر متد داشت خسته شدم! 😥😥 پیش به سوی کلاس بعدی!
---
### &nbsp; &nbsp; Entity
#### یه کلاس abstract جالبه! 🧐🧐 راستی (خاتمِ فیروزهٔ بواسحاقی🥰🥰🥰🥰خوش درخشید ولی دولتِ مُستَعجِل بود) این کلاس interfaceعه Cloneable رو implement می‌کنه.
#### فیلد‌ها بدرخشید: ✨✨
- فیلد `id` که حکم شناسنامه entity ما رو داره.
- و فیلدهای `creationDate` و `lastModificationDate` که به ترتیب زمان ساخت entity و زمان آخرین تغییراتی که روی اون اعمال شده رو می‌گه.
#### فیلدها دیگر ندرخشید متدها شما بدرخشید: ✨✨
- متدهای `getEntityCode` و `hasValidator` که هر دوی اون‌ها abstract هستن و باید حتما توی ارث‌خورهای این کلاس پیاده‌سازی بشن.
- متد ‍‍`clone` که بخاطر interfaceعه Cloneable نوشته شده و ما Override کردیم‌اش بخاطر این هست نمی‌خوایم یکی بتونه مستقیم دست بکنه تو Database ما و خرابکاری کنه و با این متد یه clone از اون entity در اختیار بقیه گذاشته می‌شه؛ اون فیلدهایی که دوباره clone شدن بخاطر این هست که deep copy صورت بگیره.
- متد `equals` بخاطر این Override شده که برحسب ID کار کنه برای entityها.

---
## &nbsp; **interface:**
### &nbsp; &nbsp; Trackable
- اون کلاس‌هایی که از این interface استفاده کنن مجبور به ساخت getter و setter برای فیلدهای Dateاشون می‌شن.
### &nbsp; &nbsp; Validator
- وظیفه این interface مجبورسازی کلاس‎‌ها به ساخت `validator` برای چکیدن (چک کردن 🥰🥰) آرمان‌ها هست.
### &nbsp; &nbsp; Serializer
- این interface می‌گه مرد حسابی بیا `serialize` و `deserialize` تعریف کن که بشه ذخیره‌ات کرد!
---
## &nbsp; **file:**
### &nbsp; &nbsp; data.json
- اگه می‌خوای کل dataهات پاک شن این فایل رو پاک کن 🥰🥰 <br/>
نه نکنی‌ها! 😭😭 چون متدهای `save` و `load` کلاس Database داده‌ها رو اینجا می‌ذخیرن.
---
## todo package
#### به پکیج اندر پکیج و کلاس اندر پکیج bonjour کنین چون حسابی قراره سرتون گیچ بره. 😵‍💫😵‍💫
## &nbsp; entity package
## &nbsp; &nbsp;**classes:**
### &nbsp; &nbsp; &nbsp; Task
#### کارها 👩🏻‍💻👨🏻‍💻
#### اوه! این کلاس interfaceعه Trackable رو implement کرده.
#### فیلداجات: 🥕🥔🍅🫛🫑🥒🥗
- کدی که به این entity تعلق می‎‌دم خیلی یهویی بدون هیچ دلیل خاصی یک هست (این کد بخاطر اینکه هیچ احدی نتونه تغییرش بده final تعریف می‌شن).
- خب اینجا `title` برای اسم کار، `description` برای توضیحات کار، `dueDate` برای موقع ددلاین کار و `status` برای وضعیت کار (اه 💔 شونصد بار گفتم کار، وای! بازم گفتم 😭😭).
- عه enum! که توش سه تا وضعیت مختلف `NotStarted` و `InProgress` و `Completed` رو در نظر می‌گیریم.
#### متدجات: 🥗🥒🫑🫛🍅🥔🥕 (لطفا دقت کنید برعکس چیده شدن خلاقیت بخرج دادم پساپس عیدتون مبارک ممنون 💖)
- توی کانستراکتور می‌آیم فیلد های `title` و `description` و `dueDate` رو مقداردهی می‌کنیم و چون تازه Task درست می‌شه خودمون فیلد `status` رو برابر `NotStarted` می‌گذاریم.
- کاملاً زوری متدهایی که بخاطر Trackable هست رو نوشتیم.
- با Override متد `getEntityCode` کد entityمون رو return می‌کنیم.
- و با Override متد `hasValidator` و return کردن true می‌گیم سوگند می‌خورم که دارای validator هستم.
- در انتها متد `clone` رو بخاطر وجود فیلد `dueDate` که دیگه دستکاری‌اش ممکن نشه تو Datebase می‌‌آیم Override می‌نماییم.
---
### &nbsp; &nbsp; &nbsp; Step
#### قدم‌ها 🐾🐾
#### فوالید:
- به این entity هم خیلی یهویی نه! چون قبلی یک بودن کد دو رو اختصاص می‌دم.
- فیلد `taskRef` برای مرتبط ساختن Step و Taskاش، فیلد `title` اسم قدمه و `status` وضعیت‌اش رو نشون می‌ده.
- خب عه enum! این دفعه کمتر گزینه داره یعنی فقط `NotStarted` و `Completed` رو داره.
#### متالید: (ایموجی آهن موجود نبود خودتون تصورش کنید مرسی 💖)
- مجدداً با Override متد `getEntityCode` کد entityمون رو return می‌کنیم.
- و دوباره مجدداً با Override متد `hasValidator` و return کردن true می‌گیم که دارای validator هستم.
- در آخر خیلی یهویی و همینطوری‌ای متد `clone` رو Override می‌کنیم (بخاطر این می‌کنیم که Step بده).
---
## &nbsp; service package
#### اکثر متدهایی که قراره توی CommandLine استفاده بشن از این package قراره برداشته بشه
#### توجه! ⚠️ چون متد‌ها خیلی زیادن ولی اکثرش قابل متوجه شدن هستن فقط سخت‌تر ها توضیح داده می‌شه
## &nbsp; &nbsp; **classes:**
### &nbsp; &nbsp; &nbsp; TaskService
- متد `updateStatus` می‌آد مقداردهی جدیدی برای فیلد `status` انجام می‌ذه ولی قرار بود اگه مقدار این فیلد برابر `Completed` بود فیلد `status` همه Stepهاش هم `Completed` بشه خب پس بریم خط بعد تا ببینیم چطوری این کار قراره انجام بشه!
- متد `automaticUpdateStatus` مشکل رو حل می‌کنه و طبق `status`عه Task برای `status`عه Stepiها تصمیم می‌گیره.
- متد ‍‍`date` می‌آد فرمت لازم برای گرفتن تاریخ رو چک می‌کنه ببینه درسته یا نه و اگه درست نبود exception می‌ده.
---
### &nbsp; &nbsp; &nbsp; StepService
- متد `addStep` شغل ایشون از اسم‌اش پیداست ولی موقع اضافه کردن یه Step جدید ممکنه به یه Taskی که `Completed` شده اضافه کنیم و باید به `InProgress` تغییر پیدا کنه اینجا هست که نیازمون به متد `automaticUpdateStatus` آشکار می‌شه.
- متد ‍‍`updateTaskRef`: عه ای بابا! Step رو دادم به Task اشتباهی چه خاکی بر سرم کنم؟ خاک رس! <br/>
آخ نه ببخشید! 😭😭 این متد همینه کارش می‌آد ‍‍`taskRef` رو اصلاح می‌نماید ولی خب توی این فرآیند ممکن هست که وضعیت انجام Task اولی و دومی تغییر کنه پس متد `automaticUpdateStatus` هلپ آس پلیز❗
- متد `updateStatus` نیز پیشه‌اش از نام‌اش نمایان هست ولی باز ممکنه با تغییر `status` یه Stepی Task اون وضعیت‌اش عوض بشه خب پس دوباره دست با دامان متد `automaticUpdateStatus` می‌شیم.
- این همه از `automaticUpdateStatus` استفاده کردیم بریم ببینیم چند مرده حلاجه: <br/>
ابتدا می‌آد به استفاده از `taskRef`ی که داریم Task مربوطه رو می‌یابه بعد کل Step هاش رو بررسی می‌کنه و بنا به اون‌ها برای وضعیت Task تصمیم ‌می‌گیره.
---
## &nbsp; validator package
#### هر شیءای برای ورود به دربار ما باید با آرمان‌هامون تطابق داشته باشه وگرنه از ورود منع می‌شه، کار validator همینه!
## &nbsp; &nbsp; **classes:**
### &nbsp; &nbsp; &nbsp; TaskValidator
- ابتدا چک می‌کنه که شیء اشتباهی تشریف نیاورده باشن و اگه اشتباه اومده باشن با یه exception راه راست هدایت می‌شن.
- وقت بازجویی رسیده: 🚨👮🏻‍♀️👮🏻‍♂️🚓 <br/>
`title`ات که خالی نیست؟ <br/>
هست؟ دستگیرش کنید! (exception)
نیست؟ خوش اومدی عزیزم. 💞
### &nbsp; &nbsp; &nbsp; StepValidator
- ایشون هم اول یه نگاه می‌کنه ببینه اصلا Step هستی یا نه؟
- بعد هم می‌بینه `title`ات خالی نباشه.
- اون دم رفتن هم `taskRef` رو چک می‌کنه ببینه اصلا همچین Taskی هست یا نه؟
- و اگه توی حتی یکی از مراحل بالا مشکلی باشه با یه exception مهمون‌تون می‌کنه.
---
## &nbsp; serializer package
#### قراره ذخیره شیم 😭😭
#### این کلاس‌ها intetfaceعه Serializer رو implement می‌کنن.
## &nbsp; &nbsp; **classes:**
### &nbsp; &nbsp; &nbsp; TaskSerializer & StepSerializer
#### چون خیلی به هم شبیه هستن با هم توضیح می‌دم!
- کار متد `serialize` اینه که بیاد فیلدهای شیء ما رو بگذاره توی یه object از کلاس JSONObject و با استفاده از متد `toString` (احتمالا Override شده هست) یه رشته‌ای رو return کنه.
- عه dataهامون هورا خب باید رمزگشایی بکنیم تا بفهمیم چی بودن مجدداً با یه object از کلاس JSONObject این رمزگشایی رو انجام می‌ده و بعد هم بصورت یه شیء return می‌شه.
---
## command package
## &nbsp; **class:**
### &nbsp; &nbsp; CommandLine 
#### قراره از اینجا بتونیم با shell کار کنیم! (اینجا نیز فقط متدهای مهم توضیح دریافت کردن باتشکر 🙏🏻)
- متدی داریم به نام `start` که اول قراره بیاد validatorها و serializerها رو register کنه بعد هم dataها رو load می‌کنه بعد می‌ریم توی یه حلقه که قراره کامندها رو از کاربر ورودی بگیریم بعد اون هم با متد `processCommand` سر و کله برنیم و سپس با نوشتن دستور exit از اون خارج می‌شیم و dataها save می‌شن و از برنامه خارج می‎‌شیم.
- متد ‍‍`processCommand` همون جایی هست که کامندها رو می‌گیره و با استفاده از switch case می‌فرستدمون به متدهای دیگه! (اگه که یه وقتی کامند اشتباهی بدیم باید دوباره تلاش کنیم)
- متد های `updateTask` و ‍‍`updateStep` میان دوباره از کاربر کامند می‌گیرن که کدوم فیلد رو می‌خوای بروز کنی بعد اگه اشتباه بزنی اتفاقی نمی‌افته و فقط باید دوباره کامندها رو بزنی و اگه درست بزنی هم مقدار جدید اون فیلد رو می‌دی و اگه با آرمان‌ها همخونی داشته باشه جایگزینی صورت می‌گیره!
---
## Main
#### ایشون فقط قراره که با متد `start` کار کلاس CommandLine رو شروع کنن همین!
(اینجوری چون logic برنامه‌مون توی کلاس Main نوشته نشده تغییر دادن و افزودن ویژگی‌های جدید به برنامه آسون‌تر می‌شه
<br/>
<br/>
تموم شد بلاخره!😭😭😭 <br/>
هورا! 🎉🎊🎈

### Au revoir!



